---
pred_bat:
  module: predbat
  class: PredBat

  # Timezone to work in
  timezone: Europe/London
  
  # Set to auto-match with a GivEnergy serial number, but you can override the serial or the sensor names
  # if it doesn't work or if you have more than one inverter you will need to list both
  geserial: 're:sensor.givtcp_(.+)_soc_kwh'
  #
  # Sensors, currently more than one can be specified (ie one for inverter) and they will be summed up automatically
  #
  load_today: 
    - sensor.givtcp_{geserial}_load_energy_today_kwh
  import_today: 
    - sensor.givtcp_{geserial}_import_energy_today_kwh
  export_today: 
    - sensor.givtcp_{geserial}_export_energy_today_kwh
  #
  # Controls/status - must by 1 per inverter
  #
  num_inverters: 1
  charge_rate: 
    - number.givtcp_{geserial}_battery_charge_rate
  discharge_rate: 
    - number.givtcp_{geserial}_battery_discharge_rate
  soc_kw: 
    - sensor.givtcp_{geserial}_soc_kwh
  soc_max: 
    - sensor.givtcp_{geserial}_battery_capacity_kwh
  reserve: 
    - number.givtcp_{geserial}_battery_power_reserve
  inverter_mode: 
   - select.givtcp_{geserial}_mode
  soc_percent: 
   - number.givtcp_{geserial}_target_soc
  charge_enable: 
   - switch.givtcp_{geserial}_enable_charge_schedule
  charge_start_time: 
   - select.givtcp_{geserial}_charge_start_time_slot_1
  charge_end_time: 
   - select.givtcp_{geserial}_charge_end_time_slot_1
  charge_limit: 
   - number.givtcp_{geserial}_target_soc
  scheduled_charge_enable: 
   - switch.givtcp_{geserial}_enable_charge_schedule
  discharge_start_time: 
   - select.givtcp_{geserial}_discharge_start_time_slot_1
  discharge_end_time: 
   - select.givtcp_{geserial}_discharge_end_time_slot_1
  
  # Set these to match solcast sensor names (unlikely to need changing)
  pv_forecast_today: sensor.solcast_forecast_today
  pv_forecast_tomorrow: sensor.solcast_forecast_tomorrow
  pv_forecast_d3: sensor.solcast_forecast_d3
  pv_forecast_d4: sensor.solcast_forecast_d4

  # For pv estimate, leave blank for central estimate, or add 10 for 10% curve (worst case) or 90 or 90% curve (best case)
  # If you use 10 then disable pv_metric10_weight below
  # pv_estimate: 10
  
  # Battery loss accounts for energy lost charging the battery, 0.05 is 5%
  # Battery loss discharge accounts for energy lost discharging the battery, 0.05 is 5%
  battery_loss: 0.05
  battery_loss_discharge: 0.05

  #Â Battery scaling makes the battery smaller (e.g. 0.9) or bigger than its reported
  # If you have an 80% DoD battery that falsely reports it's kwh then set it to 0.8 to report the real figures
  battery_scaling: 1.0

  # Scaling factor applied to historial load, tune up if you want to be more pessimistic on future consumption
  # Use 1.0 to use exactly previous load data (1.1 would add 10% to load)
  load_scaling: 1.0

  # Days previous is the number of days back to find historical load data
  # Recommended is 7 to capture day of the week but 1 can also be used
  days_previous: 7

  # Scaling factor applied to pv data, tune down if you want to be more pessimistic on PV production vs Solcast
  # Use 1.0 to use exactly the solcast data (0.9 would remove 10% from forecast)
  pv_scaling: 1.0

  # Weighting given to the 10% PV scenario, comment out or put to 0.0 to disable this
  # A value of 0.1 assumes that 1:10 times we get the 10% scenario and hence to count this in the metric benefit/cost
  pv_metric10_weight: 0.15
  
  # Number of hours forward to forecast
  forecast_hours: 48

  # The number of hours ahead to count in charge planning (for cost estimates)
  # It's best to set this on your charge window repeat cycle (24) but you may want to set it higher for more variable
  # tariffs like Agile
  # Don't set higher than forecast_hours
  forecast_plan_hours: 24
  
  # When car charging hold is enable loads of above theshold kwh are ignored in the simulation
  # Or if an incrementing energy sensor is provided actuals can be subtracted
  # The wallbox sensor is an example, automatically added if you have one, or comment our or replace with your own
  # Car charging energy scale - 1.0 if in Kwh or enter a different figure to scale the data accordingly (2.0 would double the data)
  car_charging_hold: True
  car_charging_energy: 're:sensor.wallbox_portal_added_energy'
  car_charging_energy_scale: 1.0
  car_charging_threshold: 6.0

  # car_charging_planned is set to a sensor which when positive indicates the car will charge in the low rate slots ad the rate of car_charging_rate kw
  # The list of possible values is in car_charging_planned_response
  # This should not be used if you use Octopus Intelligent Slots which will take priority if enabled
  # car_charging_planned: binary_sensor.tsunami_charger
  # car_charging_planned: sensor.wallbox_portal_status_description
  car_charging_planned: False
  car_charging_planned_response:
    - 'yes'
    - 'on'
    - 'true'
    - 'connected'
    - 'ev connected'
    - 'charging'
    - 'paused'
    - 'waiting for car demand'
    - 'scheduled'
    - 'enabled'
    - 'latched'
    - 'locked'
    - 'plugged in'
  # Sets the car charging rate in kw, can also be pulled automatically from Ocotpus Intelligent if enabled
  car_charging_rate: 7.5
  # To make planned car charging more accurate, either using car_charging_planned or Octopus Inteligent
  # specify your battery size in kwh, charge limit % and current car battery soc % sensors/values
  # If you have intelligent you don't need to use this as it allocate slots, but it may help to get a more accurate figure
  #car_charging_battery_size: 75
  #car_charging_limit: 're:number.tsunami_charge_limit'
  #car_charging_soc: 're:sensor.tsunami_battery'
  car_charging_loss: 0.08

  # If you have Octopus intelligent, enable the intelligent slot information to add to pricing
  # Will automatically disable if not found, or comment out to disable fully
  # When enabled it overrides the 'car_charging_planned' feature and predict the car charging based on the intelligent plan (unless octopus intelligent charging is False)
  octopus_intelligent_slot: 're:binary_sensor.octopus_intelligent_slot'
  octopus_intelligent_charging: True

  # Enable calculate best to work out the best battery SOC % based on cost
  calculate_best: True
  # best_soc margin : added to the final SOC estimate (in kwh) to set the battery charge level (pushes it up). 
  #                   Best not used with multiple charge windows as it tends up limit everything.
  # best_soc_min : sets the minimum charge level (in kwh) for charging during each slot (set to 0 if you want to skip some slots)
  # best_soc_keep : is minimum battery level to try to keep above during the whole period of the simulation time
  # best_soc_step: is the accuracy to calculate the charge levels to, higher values make calculations quicker, smaller ones will take longer (recommended 0.5 or 0.25)
  best_soc_margin: 0
  best_soc_min: 0
  best_soc_keep: 2
  best_soc_step: 0.25
    
  # Metric min improvement sets the minimum cost improvement that it's worth lowering the battery SOC % for
  # If it's 0 then this is disabled. 
  # A figure of around 5 (which is 5p) is a good one to use if enabled.
  # If you use pv_metric10_weight then you probably don't need to enable this as the 10% forecast does the same thing better 
  # or you could even go to something like -0.1 to say you would charge less even if it cost up to 0.1p more (best used with metric10)
  metric_min_improvement: -0.1

  # Energy rates
  # Please set one of these three, if multiple are set then Octopus is used first, second rates_import/rates_export and latestly basic metric
  
  # Set import and export entity to point to the Octopus Energy plugin
  # automatically matches your meter number assuming you have only one
  # Will be ignored if you don't have the sensor
  # Or manually set it to the correct sensor names e.g:
  # sensor.octopus_energy_electricity_xxxxxxxxxx_xxxxxxxxxxxxx_current_rate
  # sensor.octopus_energy_electricity_xxxxxxxxxx_xxxxxxxxxxxxx_export_current_rate
  metric_octopus_import: 're:sensor.octopus_energy_electricity_[0-9a-z]+_[0-9a-z]+_current_rate'
  metric_octopus_export: 're:sensor.octopus_energy_electricity_[0-9a-z]+_[0-9a-z]+_export_current_rate'
  
  # Or set your actual rates across time for import and export
  # If start/end is missing it's assumed to be a fixed rate
  # Gaps are filled with metric_house from above
  rates_import:
    -  start: "00:30:00"
       end: "04:30:00"
       rate: 7.5
    -  start: "04:30:00"
       end: "00:30:00"
       rate: 40.0
       
  rates_export:
    -  rate: 4.2

  # Can be used instead of the plugin to get import rates directly online
  # Overrides metric_octopus_import and rates_import
  # rates_import_octopus_url : "https://api.octopus.energy/v1/products/AGILE-FLEX-22-11-25/electricity-tariffs/E-1R-AGILE-FLEX-22-11-25-H/standard-unit-rates"
  # rates_import_octopus_url : "https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-A/standard-unit-rates"
  
  # Overrides metric_octopus_export and rates_export
  # rates_export_octopus_url: "https://api.octopus.energy/v1/products/FLUX-EXPORT-BB-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-BB-23-02-14-A/standard-unit-rates"

  # Or set rates to be assumed for imports for the house, charging the battery and exports
  # this method will not allow automatic setting of charging windows
  metric_house: 38
  metric_battery: 7.5
  metric_export: 4.2
    
  # Threshold below average rates as the minimum to consider for a charge window, 0.8 = 80% of average rate
  # If you set this too low you might not get enough charge slots. If it's too high you might get too many in the 24-hour period (max is 10)
  rate_low_threshold: 0.8
  
  # When enabled the next charge window will be automatically configured based on the incoming rates
  # Only works if the charging time window has been enabled and import rates are configured with the rates_import or using Octopus import
  # Set window minutes defines how many minutes before the charge window we should program it (do not set above 30 if you are using Agile or similar)
  # Will also automatically disable charging if not required and re-enable it when required. 
  # If you turn this off later check that 'GivTCP Enable Charge Schedule' is turned back on.
  set_charge_window: True
  set_window_notify: True
  set_window_minutes: 30

  # When enabled automatically discharge for export during high rate periods 
  # inverter mode and discharge start/end time entities above must be set correctly and you must have an export rate set correctly
  # exports are in 30-minute slots, not all slots will be used
  set_discharge_window: False
  set_discharge_notify: True
  
  # When enable automatically set the battery SOC charge amount a defined number of minutes before charging starts
  # note it maybe set more than once if things change
  set_soc_enable: True
  set_soc_notify: True
  set_soc_minutes: 30
  # When set_reserve_enable is true the reserve % will be reprogrammed during a charging window to match the target SOC in order
  # to prevent discharge and then reset back to minimum % outside the window. Set the set_reserve_min to your minimum reserve % 
  # which is often 4%.
  # Feature can only be used when set_soc_enable is True
  set_reserve_enable: False
  set_reserve_notify: True
  set_reserve_min: 4
  
  # Set the frequency in minutes that this plugin is run
  # recommend something that divides by 60 (5, 10 or 15) or you won't trigger at the start of energy price slots
  run_every: 5
  
  # Debug enable prints lots of debug, leave off by default
  debug_enable: False
